/*
 * Copyright 2020 Dynatrace LLC
 *
 * <p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 *
 * <p>http://www.apache.org/licenses/LICENSE-2.0
 *
 * <p>Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.dynatrace.opentelemetry.metric;

import com.dynatrace.opentelemetry.metric.mint.Datapoint;
import com.dynatrace.opentelemetry.metric.mint.Dimension;
import com.dynatrace.opentelemetry.metric.mint.MintMetricsMessage;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Splitter;
import io.opentelemetry.api.metrics.common.Labels;
import io.opentelemetry.sdk.metrics.data.AggregationTemporality;
import io.opentelemetry.sdk.metrics.data.DoublePointData;
import io.opentelemetry.sdk.metrics.data.DoubleSummaryPointData;
import io.opentelemetry.sdk.metrics.data.LongPointData;
import io.opentelemetry.sdk.metrics.data.MetricData;
import io.opentelemetry.sdk.metrics.data.ValueAtPercentile;
import java.util.*;
import java.util.logging.Logger;
import java.util.regex.Pattern;

final class MetricAdapter {

  private static final Logger logger = Logger.getLogger(MetricAdapter.class.getName());
  private static final Pattern TO_ESCAPE = Pattern.compile("[,=\\s\\\\]");
  private static final Pattern METRICKEY_NOT_ALLOWED = Pattern.compile("[^a-zA-Z0-9:_\\-]");
  private static final Pattern DOESNT_START_WITH_LETTER = Pattern.compile("[^a-zA-Z]");
  private static final Pattern DIMKEY_NOT_ALLOWED = Pattern.compile("[^a-zA-Z0-9:_\\-]");
  private static final Splitter SPLITTER = Splitter.on('.').trimResults().omitEmptyStrings();

  private MetricAdapter() {}

  private static MetricAdapter instance = null;

  /**
   * Singleton access method. Sets up a new instance if none exists and always returns that
   * instance.
   *
   * @return the instance of type {@link MetricAdapter}
   */
  public static MetricAdapter getInstance() {
    if (instance == null) {
      instance = new MetricAdapter();
    }
    return instance;
  }

  /**
   * Contains the static dimensions (i.e., tags and OneAgent metadata enrichment, if set up) that
   * are added to each MINT line sent to the ingestion API.
   */
  private Set<Dimension> constantDimensions = null;

  /**
   * Sets the dimensions (as key-value pairs) that should be added as dimensions to all metrics.
   * Keys and values are sanitized by {@link #toMintDimension}. Tags specified here will overwrite
   * any labels added by the application using instruments. These tags can only be set once, so this
   * should be called in the setup.
   *
   * @param tags A collection of tags added as dimensions to all metrics, in the form of key-value
   *     pairs mapping {@link String} to {@link String}.
   */
  public void setTags(Collection<AbstractMap.SimpleEntry<String, String>> tags) {
    if (tags == null) {
      return;
    }

    // the constantDimensions field is only populated once, and the dimensions are reused.
    if (this.constantDimensions == null) {
      Set<Dimension> localConstantDimensions = new LinkedHashSet<>();
      for (AbstractMap.SimpleEntry<String, String> tag : tags) {
        try {
          localConstantDimensions.add(toMintDimension(tag.getKey(), tag.getValue()));
        } catch (DynatraceExporterException dee) {
          logger.warning(
              String.format(
                  "Could not transform '%s/%s' to MINT dimension: %s",
                  tag.getKey(), tag.getValue(), dee.getMessage()));
        }
      }
      constantDimensions = Collections.unmodifiableSet(localConstantDimensions);
    } else {
      logger.warning("overwriting of tags not allowed. Skipping...");
    }
  }

  @VisibleForTesting
  static void resetForTest() {
    instance = null;
  }

  /**
   * Generates a MintLineProtocolSerializable MintMetricsMessage, that can be ingested to MINT.
   *
   * @param metrics are the OT metrics generated by metric instruments.
   * @return the MintMetricsMessage, that can be serialized to MINT compatible String.
   */
  static MintMetricsMessage toMint(Collection<MetricData> metrics) {
    final MintMetricsMessage.Builder builder = MintMetricsMessage.builder();
    for (MetricData metric : metrics) {
      for (Datapoint datapoint : toDatapoints(metric)) {
        builder.add(datapoint);
      }
    }
    return builder.build();
  }

  /**
   * Converts one metric to a collection of Datapoints.
   *
   * @param metric is the OT MetricData. Contains multiple points if Metrics with same key but
   *     different dimensions are recorded.
   * @return a collection of MINT compatible Datapoints.
   */
  static Collection<Datapoint> toDatapoints(MetricData metric) {
    Collection<Datapoint> datapoints = new ArrayList<>();

    if (metric.isEmpty()) { // necessary due to sometimes an empty MetricData is ingested by OT
      return Collections.emptyList();
    }
    try {
      String metricKeyName = toMintMetricKey(metric.getName());
      addGaugeData(metricKeyName, metric, datapoints);
      addSumData(metricKeyName, metric, datapoints);
      addSummaryData(metricKeyName, metric, datapoints);

      return datapoints;
    } catch (DynatraceExporterException e) {
      logger.warning(e.getMessage());
      return datapoints;
    }
  }

  private static void addSummaryData(
      String metricKeyName, MetricData metric, Collection<Datapoint> datapoints) {
    for (DoubleSummaryPointData point : metric.getDoubleSummaryData().getPoints()) {
      try {
        datapoints.add(generateSummaryPoint(metricKeyName, point));
      } catch (DynatraceExporterException e) {
        logger.warning(e.getMessage());
      }
    }
  }

  static Datapoint generateSummaryPoint(String metricKeyName, DoubleSummaryPointData summaryPoint)
      throws DynatraceExporterException {
    double min = 0.0;
    double max = 0.0;
    double sum = summaryPoint.getSum();
    long count = summaryPoint.getCount();
    List<ValueAtPercentile> valueAtPercentiles = summaryPoint.getPercentileValues();
    for (ValueAtPercentile valueAtPercentile : valueAtPercentiles) {
      // as the lowest possible percentile value is 0.0 and the highest possible is 100.0,
      // comparing the doubles directly should work
      if (valueAtPercentile.getPercentile() == 0.0) {
        min = valueAtPercentile.getValue();
      } else if (valueAtPercentile.getPercentile() == 100.0) {
        max = valueAtPercentile.getValue();
      }
    }
    SummaryStats.DoubleSummaryStat doubleSummaryStat =
        SummaryStats.doubleSummaryStat(min, max, sum, count);

    return Datapoint.create(metricKeyName)
        .timestamp(summaryPoint.getEpochNanos())
        .dimensions(getCombinedDimensions(summaryPoint.getLabels()))
        .value(Values.longGauge(doubleSummaryStat))
        .build();
  }

  private static void addSumData(
      String metricKeyName, MetricData metric, Collection<Datapoint> datapoints) {
    boolean isDeltaDouble =
        metric.getDoubleSumData().getAggregationTemporality() == AggregationTemporality.DELTA;
    for (DoublePointData data : metric.getDoubleSumData().getPoints()) {
      try {
        Datapoint p =
            Datapoint.create(metricKeyName)
                .timestamp(data.getEpochNanos())
                .dimensions(getCombinedDimensions(data.getLabels()))
                .value(Values.doubleCount(data.getValue(), /* isDelta= */ isDeltaDouble))
                .build();
        datapoints.add(p);
      } catch (DynatraceExporterException e) {
        logger.warning(e.getMessage());
      }
    }

    boolean isDeltaLong =
        metric.getLongSumData().getAggregationTemporality() == AggregationTemporality.DELTA;
    for (LongPointData data : metric.getLongSumData().getPoints()) {
      try {
        Datapoint p =
            Datapoint.create(metricKeyName)
                .timestamp(data.getEpochNanos())
                .dimensions(getCombinedDimensions(data.getLabels()))
                .value(Values.longCount(data.getValue(), /* isDelta= */ isDeltaLong))
                .build();
        datapoints.add(p);
      } catch (DynatraceExporterException e) {
        logger.warning(e.getMessage());
      }
    }
  }

  private static void addGaugeData(
      String metricKeyName, MetricData metric, Collection<Datapoint> datapoints) {

    for (DoublePointData data : metric.getDoubleGaugeData().getPoints()) {
      try {
        Datapoint p =
            Datapoint.create(metricKeyName)
                .timestamp(data.getEpochNanos())
                .dimensions(getCombinedDimensions(data.getLabels()))
                .value(Values.doubleCount(data.getValue(), /* isDelta= */ true))
                .build();
        datapoints.add(p);
      } catch (DynatraceExporterException e) {
        logger.warning(e.getMessage());
      }
    }

    for (LongPointData data : metric.getLongGaugeData().getPoints()) {
      try {
        Datapoint p =
            Datapoint.create(metricKeyName)
                .timestamp(data.getEpochNanos())
                .dimensions(getCombinedDimensions(data.getLabels()))
                .value(Values.longCount(data.getValue(), /* isDelta= */ true))
                .build();
        datapoints.add(p);
      } catch (DynatraceExporterException e) {
        logger.warning(e.getMessage());
      }
    }
  }

  /**
   * This function first transforms the given labels to dimensions using {@link
   * #convertLabelsToDimensions(Labels)} and then adds static labels that are stored in the
   * singleton instance, if there are any. If two labels have the same key, the last added label is
   * retained. Constant dimensions such as tags and OneAgent metadata labels are added last.
   *
   * @param labels the labels to be transformed by {@link #convertLabelsToDimensions}.
   * @return A list of {@link Dimension} objects to be serialized.
   */
  private static List<Dimension> getCombinedDimensions(Labels labels) {
    Set<Dimension> dynamicDimensions = convertLabelsToDimensions(labels);

    if (getInstance().constantDimensions != null) {
      dynamicDimensions.addAll(getInstance().constantDimensions);
    }

    return Collections.unmodifiableList(new ArrayList<>(dynamicDimensions));
  }

  /**
   * Converts a Map of key-value labels to a List of MINT compatible Dimensions.
   *
   * @param labels are the labels generated by OT.
   * @return all sanitized Dimensions. List is empty, if a key-value pair doesn't match the MINT
   *     requirements. The last specified label for each key will be kept, if multiple labels with
   *     the same key exists.
   */
  private static Set<Dimension> convertLabelsToDimensions(Labels labels)
      throws DynatraceExporterException {
    // LinkedHashSet will retain the order in which the elements are added.
    final Set<Dimension> dimensions = new LinkedHashSet<>();
    labels.forEach(
        (String k, String v) -> {
          try {
            dimensions.add(toMintDimension(k, v));
          } catch (DynatraceExporterException dee) {
            logger.warning(
                String.format(
                    "Could not transform '%s/%s' to MINT dimension: %s", k, v, dee.getMessage()));
            // re-throw the exception so the datapoint will be skipped
            throw dee;
          }
        });

    return dimensions;
  }

  /**
   * Sanitizes MINT metric keys regarding correct grammar.
   *
   * @param metricKey is the metric key, that needs to be sanitized.
   * @return the sanitized metric key.
   * @throws DynatraceExporterException if the metric key is null, part of the metric key (split by
   *     '.') starts with non-letter character or is empty. Further cases for returning the
   *     exception include a not allowed suffix by MINT or if the whole metric key exceeds the
   *     allowed length limits.
   */
  static String toMintMetricKey(String metricKey) throws DynatraceExporterException {
    StringBuilder builder = new StringBuilder();
    for (String metricKeySection : SPLITTER.split(metricKey)) {
      if (builder.length() != 0) {
        builder.append(".");
      }

      if (DOESNT_START_WITH_LETTER.matcher(String.valueOf(metricKeySection.charAt(0))).matches()) {
        throw new DynatraceExporterException(
            "Metric key section "
                + trimForLogOutput(metricKeySection)
                + " of key "
                + trimForLogOutput(metricKey)
                + " starts with illegal character. Discarding line.");
      }
      char[] chars = metricKeySection.toCharArray();

      for (int i = 1; i < chars.length; i++) {
        if (METRICKEY_NOT_ALLOWED.matcher(String.valueOf(chars[i])).matches()) {
          chars[i] = '_';
        }
      }
      builder.append(chars);
    }
    String sanitizedMetricKey = builder.toString();

    if (!sanitizedMetricKey.equals(metricKey)) {
      logger.info(
          "Sanitized OT metric key "
              + trimForLogOutput(metricKey)
              + " to ingested MINT metric key "
              + trimForLogOutput(sanitizedMetricKey)
              + ".");
    }
    return sanitizedMetricKey;
  }

  /**
   * Convert a key-value pair to a MINT-compatible Dimension.
   *
   * @param key is the key as String.
   * @param value is the value as String.
   * @return a MINT-compatible Dimension (sanitized key and value).
   * @throws DynatraceExporterException if an error occurred during sanitizing the Strings or if a
   *     null value was passed.
   */
  static Dimension toMintDimension(String key, String value) throws DynatraceExporterException {
    try {
      return Dimension.create(toMintDimensionKey(key), toMintDimensionValue(value));
    } catch (NullPointerException npe) {
      throw new DynatraceExporterException(npe.getMessage());
    }
  }

  /**
   * Sanitizes the dimension key to be compatible with MINT.
   *
   * @param dimensionKey is the dimension key as String.
   * @return the sanitized dimension key.
   * @throws DynatraceExporterException if the dimension key is null, a section of it is empty or
   *     starts with an illegal character (sections split by '.') or the key exceeds the MINT
   *     specification limits.
   */
  static String toMintDimensionKey(String dimensionKey) throws DynatraceExporterException {
    if (dimensionKey.startsWith(".")
        || dimensionKey.endsWith(
            ".")) { // required because String.split() doesn't work correctly if first or last
      // letter is the one to split by
      throw new DynatraceExporterException(
          "Dimension key "
              + trimForLogOutput(dimensionKey)
              + " contains empty section. Discarding line.");
    } else if (dimensionKey.length() < 1) {
      throw new DynatraceExporterException(
          "Dimension key "
              + trimForLogOutput(dimensionKey)
              + " has less than 1 character. Discarding line");
    }
    StringBuilder dimKeyBuilder = new StringBuilder();

    for (String dimKeySection : SPLITTER.split(dimensionKey)) {
      if (dimKeyBuilder.length() != 0) {
        dimKeyBuilder.append(".");
      }
      if (DOESNT_START_WITH_LETTER.matcher(String.valueOf(dimKeySection.charAt(0))).matches()) {
        throw new DynatraceExporterException(
            "Dimension key section "
                + trimForLogOutput(dimKeySection)
                + " of key "
                + trimForLogOutput(dimensionKey)
                + " starts with illegal character. Discarding line.");
      }

      // the following replaceAll are expensive operations and may have to be removed
      char[] chars =
          dimKeySection
              .replaceAll("[^\\x00-\\x7F]", "_") // replacing non-ASCII chars
              .replaceAll("[\\p{Cntrl}&&[^\r\n\t]]", "_") // replacing ASCII control chars
              .replaceAll(
                  "\\p{C}",
                  "_") // replacing non-printable chars from Unicode (evaluate if necessary!)
              .toCharArray();

      for (int i = 0; i < chars.length; i++) {
        if (DIMKEY_NOT_ALLOWED.matcher(String.valueOf(chars[i])).matches()) {
          chars[i] = '_';
        } else if (String.valueOf(chars[i]).matches("[A-Z]")) {
          chars[i] = Character.toLowerCase(chars[i]);
        }
      }
      dimKeyBuilder.append(chars);
    }

    if (!dimKeyBuilder.toString().equals(dimensionKey)) {
      logger.info(
          "Sanitized OT dimension key "
              + trimForLogOutput(dimensionKey)
              + " to ingested MINT dimension key "
              + trimForLogOutput(dimKeyBuilder.toString())
              + ".");
    }
    return dimKeyBuilder.toString();
  }

  /**
   * Sanitizes the dimension value to be compatible with MINT.
   *
   * @param dimensionValue is the dimension value as String.
   * @return the sanitized dimension value.
   * @throws DynatraceExporterException if dimension value is null or exceeds the MINT specification
   *     limits.
   */
  static String toMintDimensionValue(String dimensionValue) throws DynatraceExporterException {
    if (dimensionValue.length() < 1) {
      throw new DynatraceExporterException(
          "Dimension value "
              + trimForLogOutput(dimensionValue)
              + " does not have at least a character. Discarding the line.");
    } else {
      String escapedString = dimensionValue.replace("\\", "\\\\").replace("\"", "\\\"");
      if (!dimensionValue.equals(escapedString)) {
        logger.info(
            "Sanitized OT dimension value "
                + trimForLogOutput(dimensionValue)
                + " to ingested MINT dimension value "
                + trimForLogOutput(escapedString)
                + ".");
      }
      return escapedString;
    }
  }

  /**
   * Escapes a String with '"' if it is required by MINT.
   *
   * @param value is the input String.
   * @return '"'value'"' if value contains specific char that requires escaping, else the unmodified
   *     value.
   */
  public static String escapeIfNecessary(String value) {
    return TO_ESCAPE.matcher(value).find() ? "\"" + value + "\"" : value;
  }

  /**
   * Trims a String to it's first characters (determined by config) for a more overviewable log
   * output.
   *
   * @param value is the input String.
   * @return the trimmed String.
   */
  private static String trimForLogOutput(String value) {
    return value;
  }
}
